{% extends "base.html" %}
{% block content %}
<div class="container">
    <div id="form_config_alg" class="form-group">

    </div>
</div>

{% endblock %}
{% block js %}
<script>
    /**
    * Checks if number is in exponential format (eg: 1e-8 for 0.00000001).
    * If it does not, original number is returned.
    * If it does it converts it to string representation of that number
    * which forces it to format 0.00000001
    */
    function convertExponentialToDecimal(exponentialNumber){
        // sanity check - is it exponential number
        const str = exponentialNumber.toString();
        if (str.indexOf('e') !== -1) {
            const exponent = parseInt(str.split('-')[1], 10);
            // Unfortunately I can not return 1e-8 as 0.00000001, because even if I call parseFloat() on it,
            // it will still return the exponential representation
            // So I have to use .toFixed()
            const result = exponentialNumber.toFixed(exponent);
            return result;
        } else {
            return exponentialNumber;
        }
    }

    function toggle_click(block){
        $("#"+block).toggle("slow");
    }
    
    $("document").ready(function(){
        alg_config = {"penalty":{"type":"string","default":"l2","help":"Used to specify the norm used in the penalization. The ‘newton-cg’, ‘sag’ and ‘lbfgs’ solvers support only l2 penalties. ‘elasticnet’ is only supported by the ‘saga’ solver. If ‘none’ (not supported by the liblinear solver), no regularization is applied.","options":["l2","l1","elasticnet","none"]},"tol":{"type":"float","default":0.0001,"help":"Tolerance for stopping criteria.","min":1e-16,"max":1e+16},"C":{"type":"float","default":1,"help":"Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.","min":0,"max":1e+64},"fit_intercept":{"type":"boolean","default":true,"help":"Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function."},"class_weight":{"type":"string","default":"","help":"The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).","options":["","balanced"]},"solver":{"type":"string","default":"liblinear","help":"Algorithm to use in the optimization problem.\n\nFor small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and ‘saga’ are faster for large ones.\nFor multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ handle multinomial loss; ‘liblinear’ is limited to one-versus-rest schemes.\n‘newton-cg’, ‘lbfgs’, ‘sag’ and ‘saga’ handle L2 or no penalty\n‘liblinear’ and ‘saga’ also handle L1 penalty\n'saga’ also supports ‘elasticnet’ penalty\n‘liblinear’ does not handle no penalty","options":["liblinear","newton-cg","lbfgs","sag","saga"]},"max_iter":{"type":"integer","default":100,"help":"Maximum number of iterations taken for the solvers to converge.","min":1},"multi_class":{"type":"string","default":"ovr","help":"If the option chosen is ‘ovr’, then a binary problem is fit for each label. For ‘multinomial’ the loss minimised is the multinomial loss fit across the entire probability distribution, even when the data is binary. ‘multinomial’ is unavailable when solver=’liblinear’. ‘auto’ selects ‘ovr’ if the data is binary, or if solver=’liblinear’, and otherwise selects ‘multinomial’.","options":["ovr","multinominal","auto"]},"warm_start":{"type":"boolean","default":false,"help":"When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver."}};
        var place_in = $("#form_config_alg");
        var parameters = Object.keys(alg_config);
        var row_number = 0;
        parameters.forEach(function(i){
            row_number += 1;
            let parameter = alg_config[i];
            let row = $("<div></div>", {class: "row"});
            let block = $("<div></div>", {id: i, class: "offset-4 col-4"});
            if (row_number%2 == 1){
                block.addClass("row-odd");
            }
            row.append(block);
            block.html("<label data-toggle=\"tooltip\" title=\""+parameter.help+"\" for=\""+i+"_value"+"\">"+i+"</label>");
            block.append($("<a onClick=\"toggle_click('"+i+"_value"+"')\" href=\"#\" id=\""+i+"_open"+"\">"+
                                "<i class=\"material-icons\" style=\"float: right;\">"+
                                    "arrow_drop_down_circle"+
                                "</i>"+
                           "</a>"));
            
            let content;
            switch(parameter.type){
                case "string":
                    content = $("<select></select>", {id: i+"_value"});
                    parameter.options.forEach(function(j){
                        content.append($("<option value=\""+j+"\">"+j+"</option>"));
                    });
                    break;
                case "boolean":
                    content = $("<input/>", {type: "checkbox", id: i+"_value"});
                    if (parameter.default){
                        content.attr({checked: "checked"});
                    }
                    content.attr("data-toggle", "toggle");
                    break;
                case "float":
                    content = $("<input/>", {type: 'number',
                                                step: 'any',
                                                id: i+"_value",
                                                min: convertExponentialToDecimal(parameter.min),
                                                max: convertExponentialToDecimal(parameter.max),
                                                value: parameter.default});
                    break;
                case "integer":
                    content = $("<input/>", {type: 'number',
                                                step: 1,
                                                id: i+"_value",
                                                min: parameter.min,
                                                max: parameter.max,
                                                value: parameter.default});
                    break;
                default:
                    console.log("Parameter "+i+" has unrecognized type ("+parameter.type+")");
            }
            content.attr({class: "form-control config_alg", style: "display: none"});
            block.append(content);
            place_in.append(row);
        });
    });
    function get_config_form(){
        var parameters = Object.keys(alg_config);
        let result = {};
        parameters.forEach(function(i){
            let par = alg_config[i];
            let parameter = $("#"+i+"_value");
            result[i] = parameter.val();
            if (par.type == "boolean"){
                if (parameter.is(":checked")){
                    result[i]=true;
                }else{
                    result[i]=false;
                }
            }
        });
        return result;
    }
</script>
{% endblock %}